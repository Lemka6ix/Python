# Вариант 12

## №1.1 (с использованием рекурсии)
### Задание
Функция для вычисления всех перестановок списка длиной k.
```python
>>> k_permutaions([1, 2, 3], 2)
[[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]]
```
### Решение
```python
def plen(nums, k):
    if k == 0:
        return [[]]
    
    result = []
    for i, num in enumerate(nums):
        rest = nums[:i] + nums[i + 1:]
        for perm in plen(rest, k - 1):
            result.append([num] + perm)
    
    return result

print(plen([1, 2, 3], 2))
```

* Функция `plen(nums, k)` принимает два параметра: `nums` - список чисел, и `k` - длина перестановок, которые мы хотим найти.
* В строке `if k == 0`: проверяется базовый случай рекурсии: если k достигает 0, возвращается пустой список []. Это означает, что мы дочитались до конца длины перестановки и можем возвратить пустой список.
* Далее создается пустой список `result`, в который будут добавляться все найденные перестановки.
* Для каждого элемента num и его индекса `i` в списке `nums`, элемент num удаляется из `nums` и сохраняется в `rest`, представляющем собой список без этого элемента.
* Для каждой перестановки `perm` длины k - 1, найденной для списка `rest` рекурсивно вызывается функция `plen`. К элементу `num` добавляется каждая найденная перестановка `perm` и результат добавляется в список `result`.
* После прохода по всем элементам списка, все найденные перестановки хранятся в `result`.

### Результат выполнения программы
![result1](https://github.com/Lemka6ix/lab3/blob/main/%D0%90/3.1.png)

## №1.2 (без рекурсии)
### Задание 
Функция для вычисления всех перестановок списка длиной k.
```python
>>> k_permutaions([1, 2, 3], 2)
[[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]]
```
### Решение
```python
def pepi(nums, k):
    result = []
    stick = [(list(nums), [])]

    while stick:
        curr, permutation = stick.pop()
        if len(permutation) == k:
            result.append(permutation)
        else:
            for i in range(len(curr)):
                next_perm = permutation + [curr[i]]
                next_remain = curr[:i] + curr[i+1:]
                stick.append((next_remain, next_perm))

    return result

result = pepi([1, 2, 3], 2)
print(result)
```
* Мы используем `stick`, чтобы хранить текущие состояния перестановок.
* Начинаем с исходного списка и пустой перестановки.
* В цикле пока `stick` не пуст, мы извлекаем текущий элемент и перестановку.
* Если длина перестановки равна `k`, мы добавляем ее в результат.
* В противном случае, мы создаем новые перестановки, добавляя каждый элемент из оставшихся элементов к уже сформированным перестановкам.

### Результат
![result2](https://github.com/Lemka6ix/Python/blob/main/lab3/%D0%90/3.1%D0%B1%D0%B5%D0%B7%D1%80%D0%B5%D0%BA.png)

## №2.1 (с использованием рекурсии)
### Задание 
Функция для вычисления $x_i = ix_{i-1} + \frac{1}{i}, x_0 = 0$.

### Решение
```python
def compe(i):
    if i == 0:
        return 0
    else:
        return i * compe(i - 1) + 1 / i

index = 5
resultrec = compe(index)
print(f"Результат вычисления x с индексом {index} с рекурсией: {resultrec}")
```
* Создаем рекурсию для нахождения $x$ с индексом $i$
* В начале проверяется базовый случай: если $i$ == 0, то функция возвращает 0.
* В противном случае, для любого другого значения $i$, функция рекурсивно вызывает саму себя для $i$ - 1, умножает результат на $i$ и добавляет $\frac{1}{i}$.
* Это происходит до тех пор, пока не будет достигнут базовый случай $i$ == 0.

### Результат
![result3](https://github.com/Lemka6ix/lab3/blob/main/%D0%90/3.2.png)

## №2.2 (без рекурсии)
### Задание 
Функция для вычисления $x_i = ix_{i-1} + \frac{1}{i}, x_0 = 0$.
### Решение
```python
def sesh(i):
    result = 0
    for j in range(1, i + 1):
        result = j * result + 1 / j
    return result

index = 5
resic = sesh(index)
print(f"Результат вычисления x с индексом {index} без рекурсии: {resic}")
```
* Создаем функцию, которая решает задачу вычисления значения x с заданным индексом без использования рекурсии.
* В начале определяется переменная result и инициализируется значением 0.
* Затем запускается цикл for, который перебирает значения от 1 до i включительно (включая i).
* На каждом шаге цикла текущее значение j умножается на result, затем добавляется 1 / j, и результат сохраняется в переменной result.
* Таким образом, цикл проходит через все значения от 1 до i, обновляя result согласно указанной формуле. 

### Результат
![result4](https://github.com/Lemka6ix/lab3/blob/main/%D0%90/3.2%D0%B1%D0%B5%D0%B7%D1%80%D0%B5%D0%BA.png)
