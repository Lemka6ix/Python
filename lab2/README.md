# Вариант 12

## №1
### Задание
Игорь составляет таблицу кодовых слов для передачи сообщений, каждому сообщению соответствует своё кодовое слово. В качестве кодовых слов Игорь использует трёхбуквенные слова, в которых могут быть только буквы Ш, К, О, Л, А, причём буква К появляется ровно 1 раз. Каждая из других допустимых букв может встречаться в кодовом слове любое количество раз или не встречаться совсем. Сколько различных кодовых слов может использовать Игорь?

### Ход выполнения
```python
from itertools import product

def count_code_words():
    valers = ['Ш', 'К', 'О', 'Л', 'А']
    count = 0

    for p in product(valers, repeat=3):
        if p.count('К') == 1:
            count += 1

    return count

total_code_words = count_code_words()
print(f"Игорь может использовать {total_code_words} кодовых слов.")
```
* _from itertools import product_: Мы импортируем функцию _product_ из модуля _itertools_, которая предоставляет возможность создавать комбинации из последовательностей.
* `def count_code_words():`: Здесь мы объявляем функцию `count_code_words`, которая будет подсчитывать количество кодовых слов, удовлетворяющих определенному условию.
* `valid_letters = ['Ш', 'К', 'О', 'Л', 'А']`: Создаём список `valid_letters`, в котором содержатся допустимые буквы для составления кодовых слов.
* _count = 0_: Инициализируем переменную count, которая будет содержать количество кодовых слов, удовлетворяющих условию.
* `for p in product(valid_letters, repeat=3):` : Мы проходимся по всем комбинациям длины 3 из допустимых букв, используя функцию product из _itertools_.
* _if p.count('К') == 1:_: Проверяем каждую комбинацию, и если буква 'К' встречается в ней ровно один раз, мы увеличиваем счётчик count на 1.
* _count += 1_: Увеличиваем счётчик на 1 для каждой комбинации, где 'К' встречается ровно один раз.
* _return count_: Возвращаем общее количество кодовых слов, удовлетворяющих условию.
* `total_code_words = count_code_words()`: Вызываем функцию count_code_words и сохраняем результат в переменной `total_code_words`.
*  print(f"Игорь может использовать `{total_code_words}` кодовых слов."): Печатаем сообщение, указывающее на количество кодовых слов, которые Игорь может использовать, используя форматированную строку, где `{total_code_words}` заменяется на фактическое количество кодовых слов.
#### Результат выполнения программы 
![result1](https://github.com/Lemka6ix/Python/blob/main/lab2/images/1%20.png)



## №2
### Задание
Значение арифметического выражения $3*4^{38} + 2 * 4^{23} + 4^{20} + 3 * 4^{5} + 2 * 4^{4} + 1$ записали в системе счисления с основанием 16. Сколько значащих нулей содержится в этой записи?

### Ход выполнения
```python
def expression():
    result = 3 * 4**38 + 2 * 4**23 + 4**20 + 3 * 4**5 + 2 * 4**4 + 1
    return result

result_value = expression()
death = hex(result_value)[2:]
print(death)

def count_zeros(number):
    count = number.count('0')
    return count

zeros_count = count_zeros(death)
print("Кол-во значимых нулей - ", zeros_count)

```
* Сначала считаем само число и переводим его в 16-чную систему счисления(`def` - это `str`)
* Удаляем первые два знака у числа, котроые появились после перевода
* Считаем количество значащих нулей у этого числа
#### Результат выполнения программы 
![result2](https://github.com/Lemka6ix/Python/blob/main/lab2/images/1212.png)


## №3

### Задание
Напишите программу, которая перебирает целые числа, большие 600 000, в порядке возрастания и ищет среди них такие, среди делителей которых есть хотя бы одно число, оканчивающееся на 7, но не равное 7 и самому числу. Необходимо вывести первые 5 таких чисел, и наименьший делитель, оканчивающийся на 7, не равный 7 и самому числу.

### Ход выполнения
```python
def find_numbers():
    count = 0
    number = 600000

    while count < 5:
        number += 1
        divisor_found = False
        derg = None

        for divisor in range(2, number):
            if number % divisor == 0:
                if str(divisor)[-1] == '7' and divisor != 7 and divisor != number:
                    divisor_found = True
                    derg = divisor
                    break

        if divisor_found:
            print(number, derg)
            count += 1
            
find_numbers()
```
#### Результат выполнения программы 
![result3](https://github.com/Lemka6ix/Python/blob/main/lab2/images/1333.png)

* Создаём функцию, начинаем поиск чисел, начиная с `600000`
* Начинаем цикл `while`, с помощью которого будут найдены `5` чисел
* Создаём переменную `derg`, для хранения в ней делителя для каждого найденного числа
* Перебираем числа и проверяем их на условия задачи
_____
# Ссылки на используемые материалы
* https://clck.ru/MfEMS
* https://www.programiz.com/python-programming
* https://youtu.be/Rpf63XT5XLI?si=IJ60tBQVwI3X-i4E
* https://habr.com/ru/companies/otus/articles/529356/
